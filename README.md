# Demo repository for Jenkinsfile Runner Action for GitHub Actions

This is the demo project for [jfr-setup-action](https://github.com/jenkinsci/jfr-setup-action), 
[jfr-plugin-installation-action](https://github.com/jenkinsci/jfr-plugin-installation-action), 
[jfr-runtime-action](https://github.com/jenkinsci/jfr-runtime-action), 
[jfr-static-image-action](https://github.com/jenkinsci/jfr-static-image-action) and 
[jfr-container-action](https://github.com/jenkinsci/jfr-container-action).
You can check the [central documentation page](https://jenkinsci.github.io/jfr-action-doc/) for more details about these actions.

## Demo
All the demos are stored in the `./demo` directory. You can use them with the actions mentioned above.
1. [Java demo](./demo/java): It's a Spring Boot project. The source files are generated by [Spring Initializr](https://start.spring.io/).
2. [JavaScript demo](./demo/javascript/my-react-app): It's a React project. You can generate it by using `npm init react-app ./my-react-app` in the command line.
3. [Scala demo](./demo/scala/scalaexample): It's a Scala project. You can generate it by using `sbt new scala/scalatest-example.g8` in the command line.
4. [Jenkins secrets demo](./demo/jenkins-secrets): It teaches you how to define and use secrets in the Jenkins pipeline.
5. [Jenkins environment variables demo](./demo/jenkins-envs): It teaches you how to define and use environment variables in the Jenkins pipeline.
6. [s3-artifact-manager demo](./demo/s3-artifact-manager): It teaches you how to store the pipeline results to an external storage.
7. [jobcacher demo](./demo/jobcacher): It teaches you how to cache the pipeline dependencies.
8. [remote agent demo](./demo/remote-agent): It teaches you how to trigger the building in the remote agents.

## How you can access Jenkinsfile-runner actions in your project?
Reference these actions in your workflow definition.
1. jenkinsci/jfr-setup-action@master
2. jenkinsci/jfr-plugin-installation-action@master
3. jenkinsci/jfr-runtime-action@master
4. jenkinsci/jfr-container-action@master
5. jenkinsci/jfr-static-image-action@master

## Workflow Explanation
You can find the workflow definition in the [.github/workflows/ci.yml](.github/workflows/ci.yml).
### jenkins-static-image-pipeline
This job pulls your repository first, and the workspace will be mapped to the container provided by 
`jfr-static-image-action`. By using the `jenkinsci/jfr-static-image-action@master` and
passing the necessary inputs, you can start the pipeline. Please note that most of the GitHub Actions will become
invalid because of the isolation between the host machine and the container. You still can use `actions/checkout@v2`
to prepare your sources.
```yaml
  jenkins-static-image-pipeline:
     runs-on: ubuntu-latest
     name: jenkins-static-image-pipeline-test
     steps:
        - uses: actions/checkout@v2
        # jfr-static-image-action
        - name: Jenkins pipeline with the static image
          id: jenkins_pipeline_image
          uses:
             jenkinsci/jfr-static-image-action@master
          with:
             command: run
             jenkinsfile: Jenkinsfile
             pluginstxt: plugins.txt
             jcasc: jcasc.yml
```
### jenkins-container-pipeline
This job pulls the `ghcr.io/jenkinsci/jenkinsfile-runner:master`, pulls your repository, setup maven and run the Jenkins pipeline finally.
Please note that the declaration of `ghcr.io/jenkinsci/jenkinsfile-runner:master` is necessary to use the `jfr-container-action` action.
By using the `jenkinsci/jfr-container-action@master` and
passing the necessary inputs, you can start the pipeline.
```yaml
  jenkins-container-pipeline:
     runs-on: ubuntu-latest
     name: jenkins-prebuilt-container-test
     container:
        # prerequisite: extendance of ghcr.io/jenkinsci/jenkinsfile-runner:master
        image: path/to/your_own_image
     steps:
        - uses: actions/checkout@v2
        # jfr-container-action
        - name: Jenkins pipeline in the container
          id: jenkins_pipeline_container
          uses:
             jenkinsci/jfr-container-action@master
          with:
             command: run
             jenkinsfile: Jenkinsfile
             pluginstxt: plugins.txt
             jcasc: jcasc.yml
```
### jenkins-runtime-pipeline
This case is realized by the combination of `jfr-setup-action`, `jfr-plugin-installation-action` and `jfr-runtime-action`. 
It will download all the dependencies and run the pipeline at the host machine directly. 
Its advantage is that it can support Linux, macOS and Windows runners. 
Its main disadvantage is the possibility of suffering from a plugins.jenkins.io outage.
```yaml
  jenkins-runtime-pipeline:
     # Run all the actions in the on demand VM.
     needs: syntax-check
     strategy:
        matrix:
           os: [ubuntu-latest, macOS-latest, windows-latest]
     runs-on: ${{ matrix.os }}
     name: jenkins-runtime-pipeline-test
     steps:
        - uses: actions/checkout@v2
        - name : Setup Jenkins
          uses: jenkinsci/jfr-setup-action@master
        - name: Jenkins plugins download
          id: jenkins_plugins_download
          uses: jenkinsci/jfr-plugin-installation-action@master
          with:
             pluginstxt: plugins.txt
        - name: Run Jenkins pipeline
          id: run_jenkins_pipeline
          uses: jenkinsci/jfr-runtime-action@master
          with:
             command: run
             jenkinsfile: Jenkinsfile
             jcasc: jcasc.yml
```
